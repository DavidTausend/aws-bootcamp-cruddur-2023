# Week 2 — Distributed Tracing

Distributed tracing is a method of monitoring and understanding complex distributed systems, which are systems composed of many interconnected components that work together to provide a service. In distributed tracing, each request or transaction is tracked across all the components it touches, allowing developers and operators to trace the path of the request as it travels through the system.

A distributed tracing system typically consists of three main components:

1. Instrumentation: This involves adding code to the application to capture information about each request and its path through the system. This information is usually captured as a series of timed events and attributes, known as spans, which are associated with a unique identifier called a trace ID.

2. Trace collection: This involves collecting the spans generated by the instrumentation and sending them to a central repository or database for storage and analysis.

3. Trace analysis: This involves analyzing the collected traces to identify patterns, diagnose problems, and optimize the performance of the system. This can involve visualizing the trace data as a graph or timeline, searching for specific events or attributes, and using statistical analysis or machine learning to identify anomalies or trends.
Distributed tracing is especially useful for microservices architectures, where services are typically deployed as independent units and communicate with each other over a network. In such systems, problems can arise due to network delays, service failures, or misconfigured components, and it can be challenging to diagnose the root cause of a problem without a complete view of the request path.

By using distributed tracing, developers and operators can gain insights into the health and performance of the entire system, rather than just individual components. This can help to identify and fix problems quickly, improve the overall user experience, and ensure the reliability and scalability of the system.

## Xray

AWS X-Ray is a service offered by Amazon Web Services (AWS) that provides observability capabilities for distributed applications, helping developers understand, analyze, and debug complex distributed systems. X-Ray allows developers to trace requests across various microservices and components of a distributed application, providing insights into how requests flow through the system and identifying performance bottlenecks and errors.

Key features of AWS X-Ray include:

+ Distributed tracing: X-Ray allows developers to trace requests as they flow through a distributed application, capturing information such as request origin, service calls, and response times. This provides end-to-end visibility into the flow of requests and enables troubleshooting of performance issues and errors.

+ Service maps: X-Ray automatically generates service maps that visualize the connections and dependencies between different components of a distributed application. This helps developers understand the architecture and interactions between services, making it easier to identify potential issues and optimize performance.

+ Trace analysis: X-Ray provides powerful tools for analyzing traces, including filtering and aggregation capabilities, which allow developers to drill down into specific traces or groups of traces based on criteria such as service name, error type, or response time. This makes it easier to identify patterns and trends in trace data, aiding in troubleshooting and performance optimization.

+ Integration with AWS services: X-Ray integrates with other AWS services such as AWS Lambda, Amazon EC2, Amazon ECS, and AWS Step Functions, making it easy to add tracing capabilities to different types of applications running on AWS. X-Ray also provides SDKs for various programming languages, making it possible to instrument custom applications and capture trace data.

+ Insights and visualizations: X-Ray provides a range of visualizations and insights, including service maps, timeline views, and histograms, that help developers understand the behavior and performance of their distributed applications. These visualizations provide actionable insights that can aid in identifying and resolving issues.

AWS X-Ray is a powerful observability service that provides distributed tracing, service maps, trace analysis, and visualizations to help developers understand and optimize the behavior and performance of distributed applications running on AWS. It integrates with other AWS services and provides SDKs for custom applications, making it a valuable tool for building and operating distributed systems in the AWS ecosystem.


## Rollbar

Rollbar is a cloud-based error monitoring and exception tracking service that helps developers identify, diagnose, and resolve errors and exceptions in their software applications. It provides observability capabilities by collecting and analyzing error data in real-time, allowing developers to gain insights into the health and performance of their applications.

Key features of Rollbar include:

+ Real-time error monitoring: Rollbar continuously monitors applications in real-time, capturing and analyzing errors, exceptions, and crashes across various programming languages, frameworks, and environments. It provides detailed error reports with information such as error messages, stack traces, and request data, allowing developers to quickly identify and understand the root causes of errors.

+ Custom error tracking: Rollbar allows developers to define custom error tracking rules, enabling them to capture and track application-specific errors and exceptions. This makes it possible to monitor and analyze errors that are specific to a particular application or business logic, providing valuable insights into application behavior and performance.

+ Alerting and notifications: Rollbar provides customizable alerting and notification features that allow developers to set up notifications when specific errors or exceptions occur, based on criteria such as error severity, error rate, or error type. This enables developers to quickly respond to critical errors and take necessary actions to resolve them.

+ Integration with other tools: Rollbar integrates with various development and collaboration tools such as Slack, Jira, GitHub, and PagerDuty, allowing developers to seamlessly incorporate error monitoring into their existing workflows. This makes it easy to track and manage errors alongside other development activities.

+ Analytics and reporting: Rollbar provides analytics and reporting features that help developers gain insights into error trends, error rates, and error impact over time. This information can aid in identifying patterns, understanding error patterns, and prioritizing error resolution efforts.

+ Security and privacy: Rollbar takes security and privacy seriously, providing features such as data encryption, role-based access control, and compliance with industry standards such as GDPR and HIPAA. This ensures that error data is secure and protected, and complies with relevant data protection regulations.

Rollbar is a cloud-based error monitoring and exception tracking service that provides real-time error monitoring, custom error tracking, alerting, integration with other tools, analytics, and security features. It helps developers gain observability into their applications' error behavior, enabling them to quickly identify, diagnose, and resolve errors, and ensure the reliability and performance of their software applications.

## Cloudwatch

CloudWatch is a monitoring and observability service offered by Amazon Web Services (AWS) that provides real-time monitoring, logging, and alerting for AWS resources and applications. CloudWatch enables developers and operators to gain insights into the operational health and performance of their AWS resources, applications, and services.

Key features of CloudWatch include:

+ Monitoring: CloudWatch provides real-time monitoring capabilities for various AWS resources, including EC2 instances, RDS databases, Lambda functions, and more. It collects and aggregates metrics, logs, and events, providing a unified view of the operational health and performance of AWS resources.

+ Dashboards: CloudWatch allows users to create customizable dashboards that provide visualizations of metrics and logs, making it easy to monitor the performance and health of AWS resources at a glance. Dashboards can be shared across teams, providing a common view of operational data.

+ Alarms: CloudWatch enables users to set up alarms based on thresholds and conditions, allowing them to receive notifications when certain conditions are met or exceeded. Alarms can trigger actions such as sending notifications, stopping or terminating instances, or invoking Lambda functions, allowing users to take automated actions based on monitored metrics.

+ Logs: CloudWatch provides centralized logging capabilities, allowing users to collect, store, and analyze logs from various AWS resources and applications. CloudWatch Logs allows users to search, filter, and analyze logs in real-time, making it easier to troubleshoot issues and gain insights into application behavior.

+ Events: CloudWatch Events enables users to monitor and respond to changes and events in their AWS environment. Users can set up rules to detect changes in AWS resources, such as EC2 instance launches or RDS database modifications, and trigger automated actions in response to these events.

+ Integration with AWS services: CloudWatch integrates with many AWS services, providing native monitoring capabilities for AWS resources and services. It also supports custom metrics and logs, allowing users to instrument their applications and send custom data to CloudWatch for monitoring and analysis.

+ Insights and analytics: CloudWatch provides powerful analytics capabilities, including anomaly detection, machine learning-powered insights, and log query language, allowing users to gain deep insights into operational data and troubleshoot issues more efficiently.

+ CloudWatch is a comprehensive observability service provided by AWS that offers monitoring, logging, alerting, events, and analytics capabilities for AWS resources and applications. It enables users to gain insights into the operational health and performance of their AWS environment, helping them troubleshoot issues, optimize performance, and ensure the reliability of their applications and services.

## Observability vs Monitoring

Observability and monitoring are two important concepts in the field of cloud computing, and specifically in the context of AWS. They both involve the process of collecting and analyzing data to gain insights into the health, performance, and behavior of applications and systems running on AWS, but they have some key differences.

Observability refers to the ability to understand and gain insights into the internal state of complex systems by examining their external outputs. In other words, observability focuses on the ability to understand how a system is behaving and performing from the outside, without necessarily needing deep knowledge of its internal workings. In the context of AWS, observability can be achieved through various services such as Amazon CloudWatch, AWS X-Ray, and AWS CloudTrail.

On the other hand, monitoring involves the collection and analysis of data from various sources within a system to track its performance and health. Monitoring typically involves setting up specific metrics, thresholds, and alerts to detect issues and trigger notifications when predefined conditions are met. In the context of AWS, monitoring can be achieved through Amazon CloudWatch, which provides a wide range of monitoring capabilities such as collecting and analyzing logs, setting up custom metrics, creating alarms, and generating dashboards.

While observability and monitoring share some similarities, such as collecting and analyzing data to gain insights into system behavior, there are key differences between the two concepts. Observability emphasizes understanding system behavior from the outside, while monitoring focuses on tracking predefined metrics and conditions from within the system. Observability allows for more flexible and dynamic analysis of system behavior, while monitoring provides a more structured approach to tracking predefined metrics and conditions.

Observability and monitoring are important concepts in the context of AWS, with observability focusing on understanding system behavior from the outside and monitoring focusing on tracking predefined metrics and conditions from within the system. Both concepts are critical for ensuring the health, performance, and reliability of applications and systems running on AWS.

Source: 
https://www.youtube.com/watch?v=bOf4ITxAcXc&list=PLBfufR7vyJJ7k25byhRXJldB5AiwgNnWv&index=31

## Homework



## Frontend-application with HoneyComb


In docker-compose.yml file I added the traces and the key api for the comunication to Honeycomb:

     HONEYCOMB_TRACES_API: "https://api.honeycomb.io/v1/traces"
     HONEYCOMB_API_KEY: "${HONEYCOMB_API_KEY}"


In the requerement.txt file I added a python library:

    requests
    
In app.py I importe the new library adding the following code to test HoneyComb Fronted:

    import requests
    
    #HoneyComb Frontend
    @app.route("/honeycomb/traces", methods=['POST','OPTIONS'])
    @cross_origin(supports_credentials=True)
    def collect_traces():
        otlp_json_exported_from_frontend = request.json

        headers = {
            'Content-Type': 'application/json',
            'x-honeycomb-team': os.getenv('HONEYCOMB_API_KEY'),
        }

        try:
            response = requests.post(
                url=os.getenv('HONEYCOMB_TRACES_API'),
                json=otlp_json_exported_from_frontend,
                headers=headers
        )
        #Raise any error 4xx or 500
        response.raise_for_status()  

        return {'success': True}, 200

        except requests.exceptions.RequestException as e:
            #Handle any exceptions that occur during the POST request
            print('Error sending data to Honeycomb:', e)
            return {'success': False}, 500
    
After that the backend is done, I started working with the frontend by installing the following dependencies:

         npm install --save \
         @opentelemetry/api \
         @opentelemetry/sdk-trace-web \
         @opentelemetry/exporter-trace-otlp-http \
         @opentelemetry/context-zone
         
Then the code that will send the information to the backend:

         import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
         import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
         import { ZoneContextManager } from '@opentelemetry/context-zone';
         import { Resource } from '@opentelemetry/resources';
         import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
         import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-web';

         // Create a resource with the service name
         const resource = new Resource({
           [SemanticResourceAttributes.SERVICE_NAME]: 'frontend-react-js',
         });

         // Configure the OTLP trace exporter with the backend URL
         const exporter = new OTLPTraceExporter({
           url: `${process.env.REACT_APP_BACKEND_URL}/honeycomb/traces`,
         });

         // Configure the web tracer provider with the exporter and resource
         const provider = new WebTracerProvider({
           resource: resource,
         });

         provider.addSpanProcessor(new BatchSpanProcessor(exporter));

         // Register the provider and context manager
         provider.register({
           contextManager: new ZoneContextManager(),

Imported the file to the index.js adding the following code at the beginning:

          import './tracing.js
          
Getting the traces and span from the Homefeedpage:

     import { trace } from '@opentelemetry/api';
     
     //HoneyComb Frontend
     const tracer = trace.getTracer('frontend-ract-js');
     
     //tracer (Frontend)
       React.useEffect(()=>{
         //prevents double call
         if (dataFetchedRef.current) return;
         dataFetchedRef.current = true;

         tracer.startActiveSpan('HomeFeedPage', (span) => {
           tracer.startActiveSpan('load_data', (span) => {
             span.setAttribute('endpoint', '/api/activities/home');
             loadData();
             span.end()
           })
           tracer.startActiveSpan('check_auth', (span) => {
             span.setAttribute('endpoint', '/api/auth');
             checkAuth();
             span.end()
           })
           span.end()
         })
       }, [tracer])
       
Note: I am still having problems wiht the connection to HoneyComb.

## Add Notifications span

I added a span for the notifications in  to trace if the users are able to receive the update notification. Here is the example:

    from opentelemetry import trace

    tracer = trace.get_tracer("notifications.activities")

    class NotificationsActivities:

      def run():

        with tracer.start_as_current_span("notifications-activities-mock-data"):

          span = trace.get_current_span()

          now = datetime.now(timezone.utc).astimezone()

          span.set_attribute("notifications.now", now.isoformat())  

          span.set_attribute("notifications.result_lenght", len(results)) 

<img width="1440" alt="Week2-Span" src="https://user-images.githubusercontent.com/125006062/222908591-64e13d90-e148-48b0-bcf2-a4729ac3bbae.png">


##  Save queries in Honeycomb dasboard

1. Log in to your Honeycomb account and navigate to the dataset you want to query.
2. Click on the "Run Query" button in the top middle of the screen.
3. In the query editor, write your custom query using Honeycomb's query language. You can use the autocomplete and syntax highlighting features to help you write your query.
4. Once you have written your query, click on the "Run Query" button to execute it.
5. If the query returns the results you expect, you can give it a name clicking the "add name and description" and then save the query for later use by clicking on the "Star ⭐️"in the top middle of the screen.
In the "Save to board" select your dashboard and click "Save" to save the query.
6. To see the query, go the board and select it. 

<img width="1415" alt="Week2-HoneyCombQuery" src="https://user-images.githubusercontent.com/125006062/222908880-eae1d1a9-9421-4e76-8ade-ed4a0d6faa11.png">

<img width="1420" alt="Week2-AddBoard" src="https://user-images.githubusercontent.com/125006062/222908901-49e330a0-d283-452f-8bd5-4f606645a29b.png">

<img width="1418" alt="Week2-SaveBoard" src="https://user-images.githubusercontent.com/125006062/222908924-210b3a51-a7cc-4e09-81d9-d46b18f7bd1c.png">


<img width="1416" alt="Week2-Boards" src="https://user-images.githubusercontent.com/125006062/222908946-ce8436cc-7389-431e-8ffd-79735e2806cb.png">

Source:
https://www.youtube.com/watch?v=2GD9xCzRId4&list=PLBfufR7vyJJ7k25byhRXJldB5AiwgNnWv&index=30
https://www.youtube.com/watch?v=n2DTsuBrD_A&list=PLBfufR7vyJJ7k25byhRXJldB5AiwgNnWv&index=32
https://www.youtube.com/watch?v=ipdFizZjOF4&list=PLBfufR7vyJJ7k25byhRXJldB5AiwgNnWv&index=33
https://www.youtube.com/watch?v=xMBDAb5SEU4&list=PLBfufR7vyJJ7k25byhRXJldB5AiwgNnWv&index=35
https://www.youtube.com/watch?v=4SGTW0Db5y0&list=PLBfufR7vyJJ7k25byhRXJldB5AiwgNnWv&index=37
https://www.youtube.com/watch?v=2W3KeqCjtDY&list=PLBfufR7vyJJ7k25byhRXJldB5AiwgNnWv&index=38

