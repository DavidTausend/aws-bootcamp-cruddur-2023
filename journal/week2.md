# Week 2 — Distributed Tracing

Distributed tracing is a method of monitoring and understanding complex distributed systems, which are systems composed of many interconnected components that work together to provide a service. In distributed tracing, each request or transaction is tracked across all the components it touches, allowing developers and operators to trace the path of the request as it travels through the system.

A distributed tracing system typically consists of three main components:

1. Instrumentation: This involves adding code to the application to capture information about each request and its path through the system. This information is usually captured as a series of timed events and attributes, known as spans, which are associated with a unique identifier called a trace ID.

2. Trace collection: This involves collecting the spans generated by the instrumentation and sending them to a central repository or database for storage and analysis.

3. Trace analysis: This involves analyzing the collected traces to identify patterns, diagnose problems, and optimize the performance of the system. This can involve visualizing the trace data as a graph or timeline, searching for specific events or attributes, and using statistical analysis or machine learning to identify anomalies or trends.
Distributed tracing is especially useful for microservices architectures, where services are typically deployed as independent units and communicate with each other over a network. In such systems, problems can arise due to network delays, service failures, or misconfigured components, and it can be challenging to diagnose the root cause of a problem without a complete view of the request path.

By using distributed tracing, developers and operators can gain insights into the health and performance of the entire system, rather than just individual components. This can help to identify and fix problems quickly, improve the overall user experience, and ensure the reliability and scalability of the system.

## Homework



## Frontend-application with HoneyComb


In docker-compose.yml file I added the traces and the key api for the comunication to Honeycomb:

     HONEYCOMB_TRACES_API: "https://api.honeycomb.io/v1/traces"
     HONEYCOMB_API_KEY: "${HONEYCOMB_API_KEY}"


In the requerement.txt file I added a python library:

    requests
    
In app.py I importe the new library adding the following code to test HoneyComb Fronted:

    import requests
    
    #HoneyComb Frontend
    @app.route("/honeycomb/traces", methods=['POST','OPTIONS'])
    @cross_origin(supports_credentials=True)
    def collect_traces():
        otlp_json_exported_from_frontend = request.json

        headers = {
            'Content-Type': 'application/json',
            'x-honeycomb-team': os.getenv('HONEYCOMB_API_KEY'),
        }

        try:
            response = requests.post(
                url=os.getenv('HONEYCOMB_TRACES_API'),
                json=otlp_json_exported_from_frontend,
                headers=headers
        )
        #Raise any error 4xx or 500
        response.raise_for_status()  

        return {'success': True}, 200

        except requests.exceptions.RequestException as e:
            #Handle any exceptions that occur during the POST request
            print('Error sending data to Honeycomb:', e)
            return {'success': False}, 500
    
After that the backend is done, I started working with the frontend by installing the following dependencies:

         npm install --save \
         @opentelemetry/api \
         @opentelemetry/sdk-trace-web \
         @opentelemetry/exporter-trace-otlp-http \
         @opentelemetry/context-zone
         
Then the code that will send the information to the backend:

         import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
         import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
         import { ZoneContextManager } from '@opentelemetry/context-zone';
         import { Resource } from '@opentelemetry/resources';
         import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
         import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-web';

         // Create a resource with the service name
         const resource = new Resource({
           [SemanticResourceAttributes.SERVICE_NAME]: 'frontend-react-js',
         });

         // Configure the OTLP trace exporter with the backend URL
         const exporter = new OTLPTraceExporter({
           url: `${process.env.REACT_APP_BACKEND_URL}/honeycomb/traces`,
         });

         // Configure the web tracer provider with the exporter and resource
         const provider = new WebTracerProvider({
           resource: resource,
         });

         provider.addSpanProcessor(new BatchSpanProcessor(exporter));

         // Register the provider and context manager
         provider.register({
           contextManager: new ZoneContextManager(),

Imported the file to the index.js adding the following code at the beginning:

          import './tracing.js
          
Getting the traces and span from the Homefeedpage:

     import { trace } from '@opentelemetry/api';
     
     //HoneyComb Frontend
     const tracer = trace.getTracer('frontend-ract-js');
     
     //tracer (Frontend)
       React.useEffect(()=>{
         //prevents double call
         if (dataFetchedRef.current) return;
         dataFetchedRef.current = true;

         tracer.startActiveSpan('HomeFeedPage', (span) => {
           tracer.startActiveSpan('load_data', (span) => {
             span.setAttribute('endpoint', '/api/activities/home');
             loadData();
             span.end()
           })
           tracer.startActiveSpan('check_auth', (span) => {
             span.setAttribute('endpoint', '/api/auth');
             checkAuth();
             span.end()
           })
           span.end()
         })
       }, [tracer])
       
Note: I am still having problems wiht the connection to HoneyComb.

## Add Notifications span

I added a span for the notifications in  to trace if the users are able to receive the update notification. Here is the example:

    from opentelemetry import trace

    tracer = trace.get_tracer("notifications.activities")

    class NotificationsActivities:

      def run():

        with tracer.start_as_current_span("notifications-activities-mock-data"):

          span = trace.get_current_span()

          now = datetime.now(timezone.utc).astimezone()

          span.set_attribute("notifications.now", now.isoformat())  

          span.set_attribute("notifications.result_lenght", len(results)) 

<img width="1440" alt="Week2-Span" src="https://user-images.githubusercontent.com/125006062/222908591-64e13d90-e148-48b0-bcf2-a4729ac3bbae.png">


##  Save queries in Honeycomb dasboard

1. Log in to your Honeycomb account and navigate to the dataset you want to query.
2. Click on the "Run Query" button in the top middle of the screen.
3. In the query editor, write your custom query using Honeycomb's query language. You can use the autocomplete and syntax highlighting features to help you write your query.
4. Once you have written your query, click on the "Run Query" button to execute it.
5. If the query returns the results you expect, you can give it a name clicking the "add name and description" and then save the query for later use by clicking on the "Star ⭐️"in the top middle of the screen.
In the "Save to board" select your dashboard and click "Save" to save the query.
6. To see the query, go the board and select it. 

<img width="1415" alt="Week2-HoneyCombQuery" src="https://user-images.githubusercontent.com/125006062/222908880-eae1d1a9-9421-4e76-8ade-ed4a0d6faa11.png">

<img width="1420" alt="Week2-AddBoard" src="https://user-images.githubusercontent.com/125006062/222908901-49e330a0-d283-452f-8bd5-4f606645a29b.png">

<img width="1418" alt="Week2-SaveBoard" src="https://user-images.githubusercontent.com/125006062/222908924-210b3a51-a7cc-4e09-81d9-d46b18f7bd1c.png">


<img width="1416" alt="Week2-Boards" src="https://user-images.githubusercontent.com/125006062/222908946-ce8436cc-7389-431e-8ffd-79735e2806cb.png">

